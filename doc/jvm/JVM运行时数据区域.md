运行时数据区域
========
##### 概述
Java虚拟机在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域。

方法区（Method Area）,虚拟机栈（VM Stack），本地方法栈（Native Method Stack），堆（Heap），程序计数器（Program Couter Register）
![图解](https://upload-images.jianshu.io/upload_images/8907519-88132a26a2e08b2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 程序计数器
内存空间小，可以看作是当前线程锁执行字节码的行号指示器。字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令。

Java虚拟机的多线程通过线程轮流且混并分配处理器执行时间的方式实现，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。

如果线程执行的是一个Java方法，程序计数器记录的 是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，则程序计数器为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

##### Java虚拟机栈
线程私有的，生命周期与线程一样；每个方法在执行的时候都会创建一个帧栈，用于存储巨变变量表，操作栈，动态链接，方法出口等；每一个方法被调用直至执行完成的过程，就对应这一个帧栈在虚拟机栈中从入栈到出栈的过程。

虚拟机栈中的局部变量表存放了编译器可知的各种基本数据类型，对象引用和returnAddress类型（指向一条字节码指令的地址）。
long和double类型的数据会占用2个局部变量空间，其余的数据类型占用1个。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变局部变量表的大小。

此区域存在两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存时会抛出OutOfMemoryError。
##### 本地方法栈
本地方法栈为虚拟机使用到的Native方法服务。其作用和虚拟机栈的作用非常相似。也会抛出StackOverflowError和OutOfMemoryError异常。
##### Java堆
Java虚拟机所管理内存中最大的一块。被所有线程共享的一块内存区域，在虚拟机启动时创建。唯一目的是存放对象实例。Java堆是垃圾收集器管理的主要区域。可以分为新生代和老年代。再细致一点的有Eden空间，From Survivor空间，To Survivor空间。

Java对可以处于物理上不连续的内存空间中，只要逻辑上连续的即可。（-Xmx和-Xms可以扩展实现内存大量小）。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
##### 方法区
各个线程共享的内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。Java虚拟机规范把方法去描述为堆的一个逻辑部分。

HotSpot虚拟机使用永久代来实现方法区。

这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。一般来说对这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载。但是对这部分区域的回收确实是有必要的。
当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。
##### 运行时常量池
是方法区的一部分，Class文件中除了有类的版本、字段、方法。接口等描述信息，还有常量池。用于存放编译期生成的各种字面量和符号引用，在类加载后存放到方法区的运行时常量池。

一般来说，常量池除了保存Class文件描述的符号引用外，还会把编译出来的直接引用也存储在运行时常量池。

运行时常量池相对于Class文件常量池还具有动态性，常量并不要求在编译期产生，运行期间也可能将新的常量放入池中，如String的intern()方法。

当无法申请到内存时，会抛出OutOfMemoryError异常。
##### 直接内存
不是虚拟机的一部分，如果频繁调用，也可能会出现OutOfMemoryError异常。

JDK1.4加入了NIO(New Input/Output),，引入了基于通道与缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java对立面的DirectBuffer对象作为这块内存的引用直接操作。