内存模型
====
##### 概述
计算机所有的运算任务都不可能只靠处理器计算就能完成，至少与内存的交互，如读取运算数据、存储运算结果等，就是很难消除的。为了读写速度尽可能快，所以计算机加了一层接近处理运算速度的高速缓存作为内存和处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互能很好的解决处理器和内存的速度矛盾，但是同时也存在缓存一致性问题。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一内存。
![图片](https://upload-images.jianshu.io/upload_images/8907519-5b19213a8daad2f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
当多个处理器的运算任务都设计同一块主内存区域时，将可能导致搁置的缓存数据不一致的情况。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，如MSI,MESI,MOSI,Synapse,Firefly及Dragon Protocol等。在Java虚拟机内存模型中定义访问操作与硬件的缓存访问操作是具有可比性的。
初次之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序和输入代码中的顺序一直。与处理器的乱序执行优化类似，Java虚拟机的即时编译器也有类似的指令重排序优化。
##### Java的内存模型
1. 主内存和工作内存
Java内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存。线程的工作内存中保存了被该现场使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接进行读写主内存中的变量。不同线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。
![图片](https://upload-images.jianshu.io/upload_images/8907519-facf6451cd1fd81a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. 内存间交互操作
* lock-锁定：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* unlock-解锁：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* read-读取：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
* load-载入：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* use-使用：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，没开当虚拟机原道一个需要使用到变量的值的字节码指令时将会执行这个操作。
* assign-赋值：作用于工作内存的变量，它把一个从执行引擎收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* store-存储：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，一遍随后的write操作使用。
* write-写入：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。
**对于上述操作有如下规则：**
* 不允许read和load、store和write操作之一单独出现。
* 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
* 不允许一个线程无原因地（没有发生过assign操作）把数据从线程的工作内存同步回主内存中。
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化的变量，也就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
* 一个变量在同一时刻只允许一条线程对其进行lock操作，但是lock操作可以被同一线程重复执行多次，多次lock，需要执行相同次数的unlock操作，变量才会解锁。
* 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量钱，需要重新执行load和assign操作初始化变量的值。
* 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个呗其他线程锁定住的变量。
* 对一个变量执行unlock操作前，必须先把此变量同步回主内存中，即执行store和write操作。
3. volatile
    volatile是Java虚拟机提供的最轻量级的同步机制。
    volatile保证此变量对所有线程的可见性，volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立即反应到其他线程之中。volatile变量在各个线程的工作内存中不存在一致性问题，每次使用该变量之前，都会先将该变量在主内存中的值刷新到工作内存中。但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样不安全。
    由于volatile变量只能保证可见性，所以volatile只能在：
    * 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；
    * 变量不需要去其他的状态变量共同参与不变约束； 
  
    这两种情况下，如果在不满足这两种要求的情况下，还需要使用synchronized来保证原子性。
    同时volatile禁止指令重排序优化。
    volatile变量在渡槽走的性能消耗和普通变量几乎没有差别，但是在写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。
4. long和double变量的特殊规则
    Java内存模型要求lock，unlock，read，load，assign，use，store，write操作都具有原子性；但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来允许，即允许虚拟机实现选择可以不保证64位数据类型的load，store，read和write这四个原子特性。

5. 原子性，可见性，有序性
    * 原子性，即这系列操作要么全部执行完，要么全部不执行，在Java内存模型中read,load,assign,use,store,write这六个操作保证了原子性。基本数据类型的访问读写是具备原子性的。
    如果应用场景需要一个更大范围的原子性保证，可以使用lock和unlock操作，或者monitorenter和monitorexit两种隐式操作即sychronized关键字，所以在sychronized块之间的操作也具备原子性。
    * 可见性，可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，volatile变量保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，所以volatile保证了变量的可见性；同时sychronized和final也实现了可见性，同步块的可见性是由“对一个便携执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的；而final的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么其他线程中就能看见final字段的值。
    * 有序性：Java中volatile和sychronize都保证了线程之间操作的有序性。volatile关键字本身就包含了禁止指令重排序的语义；而synchronized则是由“一个变量同一时刻只允许一条线程对其进行lock操作”这条规则获得的。这条规则决定了持有同一个锁的两个同步块只能串行地进入。
  
6. Happen-before原则
   * 程序次序原则：在一个线程内，按照程序代码顺序，书写在前面的操作先发送在书写在后面的操作。准确的说应该是控制流顺序而不是程序代码顺序。
   * 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。
   * volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
   * 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
   * 线程终止原则：线程的所有操作都先发生于此线程的终止检测。
   * 线程中断原则：对线程interrupt()方法的调用先发生于被中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
   * 对象终结原则：一个对象的初始化完成先于发生于它的finalize()方法的开始。
   * 传递性：如果A先于B，B先于C，那么A先于C。
  
7. Java线程
    Java线程的调度方式是抢占式调度。
    Java线程的状态：
    ![图片](https://upload-images.jianshu.io/upload_images/8907519-fd854e858d07629f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   * New-新建：创建后尚未启动的状态。
   * Runnable-运行：Runnable包括了Running和Ready,也就是处于此窗台的线程有可能正在执行，也有可能正在等待CPU为他分配执行时间。
   * Waiting-无限期等待：处于这种状态的线程不会被CPU分配执行时间，需要被其他线程显示的唤醒。进入这种状态有：
    > 没有设置Timeout参数的Object.wait()方法；
    没有设置Timeout参数的Thread.join()方法；LockSupport.park()方法。

   * Timed Waiting-限期等待：处于这种状态线程也不会被分配CPU执行时间，不过不需要等待被其他线程显示的唤醒，在一定时间后他们会被系统自动唤醒，进入这种状态有：
    > Thread.sleep()方法； 
    设置了Timeout参数的Object.wait()方法；
    设置了Timeout参数的Thread.join()方法；LockSupport.parkNanos()方法，
    LockSupport.parkUntil()方法；
   * Blocked-阻塞： 阻塞状态在等待获取一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生。
   * Terminated-结束：已终止线程的线程状态，线程已经结束执行。