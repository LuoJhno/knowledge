对象生成及判定死亡算法
========
##### 判断对象是否已死
**引用计数法**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。

引用计数法实现简单，判定效率高，但是很难解决对象之间的相互引用问题，所以Java没有采用。

如objA和objB都有字段instance，赋值令

    objA.instance = objB;
    objB.instance = objA  
所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（对象不可达），则证明此对象是不可用的。
**GC Root对象包括**：
虚拟机栈（栈帧的本地变量表）中的引用的对象。
方法区的类静态属性引用的对象。
方法区中的常量引用的对象。
本地方法栈中JNI(Native方法)的引用的对象。
##### 引用
JDK1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

JDK1.2之后，将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）四种。

    强引用，类似于Object obj = new Object();只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
    软引用，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。
    弱引用，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
    虚引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法根据虚引用来去的一个对象实例。

##### 根搜索算法
如果对象在进行跟搜索后发现没有与GC Roots相链接的引用链，那它将被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机都将这两种情况视为"没有必要执行"。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条虚拟机自动建立的，低优先级的Finalizer线程区执行。这里的执行是指虚拟机会触发这个方法，但是并不承诺会等待它运行结束。

finalize()方法是对象逃脱失望的最后一次机会，稍后GC将对F-Queue的对象进行第二次小规模标记，如果对象要在finalize()中重新与引用链上的任何一个对象建立关联即可。那在第二次标记时它将被移除出即将回收集合。

finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，他的finalize()方法不会被再次执行。

finalize()方法能做的所有工作，使用try-finally或其他方式都可以做的更好，更及时。
##### 回收方法区
在方法区中进行垃圾回收性价比一般较低。
永久代的垃圾收集主要回收废弃常量和无用的类。
回收废弃常量：没有地方引用这个常量，且发生内存回收，有必要的话，这个常量就会被回收。
无用的类：

    该类的所有实例都已经被回收。
    加载该类的ClassLoader已经被回收。
    该类对应的java.lang.Class对象没有任何地方引用，无法在任何地方通过反射该类的方法。

虚拟机可以对满足以上条件的无用类进行回收。

    在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。

    不是虚拟机的一部分，如果频繁调用，也可能会出现OutOfMemoryError异常。

    JDK1.4加入了NIO(New Input/Output)，引入了基于通道与缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java对立面的DirectBuffer对象作为这块内存的引用直接操作。